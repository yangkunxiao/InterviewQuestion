### let const
#### let 
和 var相似，都是用于声明变量，不同的是，let声明的变量不存在变量提升机制，变量只能先声明后使用，即会形成暂时性死区TDZ。而且let声明的变量不可以重复声明，否则会报错。使用let命令还会形成一个块级作用域，在es5中只有全局作用域和函数级作用域，如果在特殊情况下需要使用块级作用域的时候，只能使用IIFE进行模拟。在es6中提供了let命令，新增了块级作用域的概念。而且在es5中函数只能在全局作用域和函数作用域中声明，但是在es6中，函数是可以在块级作用域中声明的，且声明的块级作用域函数会被提升到块级作用域顶端或者全局作用域。

#### const

const命令用于声明一个只读的常量，切该常量必须在声明是赋值，且一旦赋值 无法发生改变。

const声明和let声明一样只会在块级作用域内有效。

其实，const声明的常量，如果是一个基本数据类型，那么它是无法改变的。如果是一个引用类型的，那么const常量仅仅保存的是指向该
引用类型内存位置的指针，此时，该引用类型内部的属性是可以发生改变的。


### 解构赋值

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构

#### 数组的解构赋值

let [a, b, c] = [1, 2, 3];

本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

如果等号右边的只能对应一部分等号左边的 则解构不成功。

如果等号左边的只能对应等号右边的一部分 则属于不完全解构

事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。

而且解构赋值可以有默认值。

注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。


#### 对象的解构赋值


#### 字符串的解构赋值

字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。

类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。

#### 数字和布尔的解构赋值

解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。

```javascript

let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true

```

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

#### 函数参数的解构赋值


### 字符串

#### Unicode表示法

es6增强了对Unicode的支持，允许使用\uxxxx表示一个字符，其中xxxx表示字符的码点。但是这种表示法仅限于0x0000 到 0xFFFF之间，超过了该范围，则需使用双字节表示\uxxxx\uxxxx。

其实这里涉及到了Unicode的一点知识。

在早起，计算机设计时，使用8个bite为为一个字节，一个字节最大能够表示的数为2^8 - 1 = 256，而ASCII码使用0-127类表示字母、数字及一些符号。如果需要表示汉字，则一个字节显示是不够的，所以中国发明类GB2312编码将中文编码。为了统一世界上所有的文字编码，Unicode应运而生。Unicode采用双字节表示一个字符，原有的英文字符从单字节变为双字节，高位补0.
在表示一个Unicode的字符时，通常会用“U+”然后紧接着一组十六进制的数字来表示这一个字符。在基本多文种平面（英文为 Basic Multilingual Plane，简写 BMP。它又简称为“零号平面”, plane 0）里的所有字符，要用四位十六进制数（例如U+4AE0，共支持六万多个字符）；在零号平面以外的字符则需要使用五位或六位十六进制数了。

#### es6为字符串添加了iterator接口

#### 模版字符串

#### 新增的字符串方法

es5                             es6
String.fromCharCode             String.fromCodePoint        用于从码点返回对应的字符

String.charCodeAt               String.codePointAt          用于从字符返回对应的码点


#### includes 、startWith、endWith、repeat

- includes()：返回布尔值，表示是否找到了参数字符串。

- startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。

- endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。

- repeat方法返回一个新字符串，表示将原字符串重复n次。

es7 字符补全

- padStart()

- padEnd()

padStart()和padEnd()一共接受两个参数，第一个参数是字符串补全生效的最大长度，第二个参数是用来补全的字符串。

es8

- trimStart()

- trimEnd()

trimStart()消除字符串头部的空格，trimEnd()消除尾部的空格。它们返回的都是新字符串，不会修改原始字符串。

### 数字的扩展

- Number.isFinite() 数字是否是无限的
- Number.isNaN() 判断数字是否是NaN
- Number.isInteger() 判断数字是否是整数
- Number.EPSILON 常量 用于表示JavaScript能够表示的最小的精度

#### Math对象的扩展

- Math.trunc() 方法用于去除一个数的小数部分，返回整数部分。
- Math.sign() 方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。
    - 参数为正数，返回+1；
    - 参数为负数，返回-1；
    - 参数为 0，返回0；
    - 参数为-0，返回-0;
    - 其他值，返回NaN。

- Math.cbrt()方法用于计算一个数的立方根。
- Math.clz32()方法将参数转为 32 位无符号整数的形式，然后返回这个 32 位值里面有多少个前导 0。

es7 

- 指数运算符 **

es2020 引入了BigInt数据类型 后缀为n


### 函数

- 参数默认值
- rest参数
- 箭头函数
- 尾调用优化


### 数组

- 扩展运算符 ...
- Array.from Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。
- Array.of Array.of方法用于将一组值，转换为数组.当没有参数时，返回一个空数组；当只有一个参数时，返回对应参数长度的数组；当有多个参数时，返回新的数组。
- 在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组，会改变当前数组。
    - target（必需）：从该位置开始替换数据。如果为负值，表示倒数。
    - start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示从末尾开始计算。
    - end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示从末尾开始计算。

- find  数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。
- findIndex  返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。
这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。

- fill 填充数组
-  entries()，keys() 和 values() 
- includes() Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值.该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。
- flat 如果原数组有空位，flat()方法会跳过空位。
- flatMap flatMap()方法对原数组的每个成员执行一个函数（相当于执行Array.prototype.map()），然后对返回值组成的数组执行flat()方法。该方法返回一个新数组，不改变原数组。 flatMap()只能展开一层数组